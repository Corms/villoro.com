# --------------------------------------------------------------------------------------------------
# Basic metadata
# --------------------------------------------------------------------------------------------------
code: numba
title: Python performance I - numba
title_short: Numba - performance
date: "2019-05-12"
image: numba_square.png
highlight: True

tags:
  - Python
  - Performance

tags_filter:
  - Python
  - Performance

# --------------------------------------------------------------------------------------------------
# Extra info. This will add a button with href to the url
# --------------------------------------------------------------------------------------------------
link: 
  text: Github
  url: https://github.com/villoro/v-crypt


# --------------------------------------------------------------------------------------------------
# Content
# --------------------------------------------------------------------------------------------------
brief_markdown: |
  brief

image_head:
  filename: numba.svg
  caption: numba

use_chartjs: True

content_markdown: |
  This is the first post about python performance where and how to make python code go faster.

  ## 1. Exploring python compilers
  The first way to improve the python performance is by using different compilers. The most famous ones are:

  * [cython](https://cython.org/)
  * [pypy](https://pypy.org/)
  * [numba](http://numba.pydata.org/)

  **Numba** and **cython** are similar in terms of speed and **pypy** is a little bit slower. You can read more at [this quora question](https://www.quora.com/How-do-Cython-Numba-and-PyPy-compare-in-terms-of-performance-ease-of-use-and-restrictions).

  ### 1.1. Cython overview
  **Cython** is an optimising static compiler for both the Python programming language and the extended Cython programming language (based on Pyrex).

  When using cython you will need to specify variables classes so the code will look slightly different. For example:

  ```cython
  cdef int a = 0
  for i in range(10):
      a += i
  print(a)
  ```

  You can also cythonize python code. So for example you can create a file to compute Fibonacci series:

  <div class="input">
    fib.pyx
  </div>
  ```python
  def fib(n):
      """Print the Fibonacci series up to n."""
      a, b = 0, 1
      while b < n:
          print(b, end=' ')
          a, b = b, a + b

      print()
  ```

  And then transform it to **cython**:

  ```python
  from distutils.core import setup
  from Cython.Build import cythonize

  setup(
      ext_modules=cythonize("fib.pyx"),
  )
  ```
  
  Even though cython is fast I don't like having to change the code to adapt it to cython.

  ### 1.2. Pypy overview

  **PyPy** is a fast, compliant alternative implementation of the Python language (2.7.13 and 3.5.3, 3.6). It has several advantages and distinct features:

  * **Speed:** thanks to its Just-in-Time compiler, Python programs often run faster on PyPy. (What is a JIT compiler?)
  * **Memory usage:** memory-hungry Python programs (several hundreds of MBs or more) might end up taking less space than they do in CPython.
  * **Compatibility:** PyPy is highly compatible with existing python code. It supports cffi and can run popular python libraries like twisted and django.
  * **Stackless:** PyPy comes by default with support for stackless mode, providing micro-threads for massive concurrency.

  When using **pypy** you can write regular python code. The main disadvantage of pypy is that you can't use other libraries out of the box. So if for example you wan to use **pandas** you will need a **pypy** implementation of it. This makes using pypy along common python packages unconvinient. 

  ### 1.3. Numba overview

  **Numba** translates Python functions to optimized machine code at runtime using the industry-standard LLVM compiler library. Numba-compiled numerical algorithms in Python can approach the speeds of C or FORTRAN.

  You don't need to replace the Python interpreter, run a separate compilation step, or even have a C/C++ compiler installed. Just apply one of the Numba decorators to your Python function, and Numba does the rest.

  So you can use python code without modifications and you won't have compatibility problems with other packages when using numba. This is the reason I preffer **numba** over **cython** and **pypy** and it is also one of the faster of the three.

  ## 2. Using numba

  <table class="v-table v-table-right" align="center">
    <tr class="v-table-center">
      <th class="v-table-header">numpy size</th>
      <th class="v-table-header">iter_and_sum</th>
      <th class="v-table-header">jit</th>
      <th class="v-table-header">njit</th>
      <th class="v-table-header">np.sum</th>
      <th class="v-table-header">sum</th>
    </tr>
    <tr>
      <td class="v-table-center">10^4</td>
      <td>0.000926</td>
      <td>0.000160</td>
      <td>0.000076</td>
      <td>0.000008</td>
      <td>0.000750</td>
    </tr>
    <tr>
      <td class="v-table-center">10^5</td>
      <td>0.009162</td>
      <td>0.000009</td>
      <td>0.000010</td>
      <td>0.000042</td>
      <td>0.007416</td>
    </tr>
    <tr>
      <td class="v-table-center">10^6</td>
      <td>0.092385</td>
      <td>0.000107</td>
      <td>0.000120</td>
      <td>0.000407</td>
      <td>0.075906</td>
    </tr>
    <tr>
      <td class="v-table-center">10^7</td>
      <td>0.936596</td>
      <td>0.002313</td>
      <td>0.002352</td>
      <td>0.004406</td>
      <td>0.766648</td>
    </tr>
    <tr>
      <td class="v-table-center">10^8</td>
      <td>9.353938</td>
      <td>0.021365</td>
      <td>0.020550</td>
      <td>0.042787</td>
      <td>7.554794</td>
    </tr>
    <tr>
      <td class="v-table-center">10^9</td>
      <td>95.908613</td>
      <td>0.240599</td>
      <td>0.224245</td>
      <td>0.432378</td>
      <td>76.493193</td>
    </tr>
  </table>

  <canvas id="chart_sum_times" style="width:100%;height:600px;"></canvas>

scripts: |
  <script>
    var chart_sum_times = new Chart("chart_sum_times", {
      type: 'line',
      data: {
        labels: ['10^4', '10^5', '10^6', '10^7', '10^8', '10^9'],
        datasets: [
          {
            label: 'iter_and_sum',
            borderColor: "#F44336", 
            data: [0.000926, 0.009162, 0.092385, 0.936596, 9.353938, 95.908613],
            fill: false
          },
          {
            label: 'sum',
            borderColor: "#FF9800", 
            data: [0.00075, 0.007416, 0.075906, 0.766648, 7.554794, 76.493193],
            fill: false
          },
          {
            label: 'np.sum',
            borderColor: "#03A9F4", 
            data: [0.000008, 0.000042, 0.000407, 0.004406, 0.042787, 0.432378],
            fill: false
          },
          {
            label: 'jit',
            borderColor: "#8BC34A", 
            data: [0.00016, 0.000009, 0.000107, 0.002313, 0.021365, 0.240599],
            fill: false
          },
          {
            label: 'njit',
            borderColor: "#4CAF50", 
            data: [0.000076, 0.000010, 0.00012, 0.002352, 0.02055, 0.224245],
            fill: false
          },
        ],
      },
      options: {
        title: {
          display: true,
          text: 'Time of different sum functions'
        },
        scales: {
          yAxes: [{
            scaleLabel: {
              display: true,
              labelString: 'Time [s]'
            },
            type: 'logarithmic',
          }],
          xAxes: [{
            scaleLabel: {
              display: true,
              labelString: 'Size of the numpy array'
            },
          }],
        }
      }
    });
  </script>
  