# --------------------------------------------------------------------------------------------------
# Basic metadata
# --------------------------------------------------------------------------------------------------
code: numba
title: Python performance I - numba
title_short: Numba - performance
date: "2019-05-12"
image: numba_square.png
highlight: True

tags:
  - Python
  - Performance

tags_filter:
  - Python
  - Performance

# --------------------------------------------------------------------------------------------------
# Extra info. This will add a button with href to the url
# --------------------------------------------------------------------------------------------------
# link: 
#   text: Github
#   url: TODO


# --------------------------------------------------------------------------------------------------
# Content
# --------------------------------------------------------------------------------------------------
brief_markdown: |
  brief

image_head:
  filename: numba.svg
  caption: numba

use_chartjs: True

content_markdown: |
  This is the first post about python performance where and how to make python code go faster.

  ## 1. Exploring python compilers
  The first way to improve the python performance is by using different compilers. The most famous ones are:

  * [cython](https://cython.org/)
  * [pypy](https://pypy.org/)
  * [numba](http://numba.pydata.org/)

  **Numba** and **cython** are similar in terms of speed and **pypy** is a little bit slower. You can read more at [this quora question](https://www.quora.com/How-do-Cython-Numba-and-PyPy-compare-in-terms-of-performance-ease-of-use-and-restrictions).

  ### 1.1. Cython overview
  **Cython** is an optimising static compiler for both the Python programming language and the extended Cython programming language (based on Pyrex).

  When using cython you will need to specify variables classes so the code will look slightly different. For example:

  ```cython
  cdef int a = 0
  for i in range(10):
      a += i
  print(a)
  ```

  You can also cythonize python code. So for example you can create a file to compute Fibonacci series:

  <div class="input">
    fib.pyx
  </div>
  ```python
  def fib(n):
      """Print the Fibonacci series up to n."""
      a, b = 0, 1
      while b < n:
          print(b, end=' ')
          a, b = b, a + b

      print()
  ```

  And then transform it to **cython**:

  ```python
  from distutils.core import setup
  from Cython.Build import cythonize

  setup(
      ext_modules=cythonize("fib.pyx"),
  )
  ```
  
  Even though cython is fast I don't like having to change the code to adapt it to cython.

  ### 1.2. Pypy overview

  **PyPy** is a fast, compliant alternative implementation of the Python language (2.7.13 and 3.5.3, 3.6). It has several advantages and distinct features:

  * **Speed:** thanks to its Just-in-Time compiler, Python programs often run faster on PyPy. (What is a JIT compiler?)
  * **Memory usage:** memory-hungry Python programs (several hundreds of MBs or more) might end up taking less space than they do in CPython.
  * **Compatibility:** PyPy is highly compatible with existing python code. It supports cffi and can run popular python libraries like twisted and django.
  * **Stackless:** PyPy comes by default with support for stackless mode, providing micro-threads for massive concurrency.

  When using **pypy** you can write regular python code. The main disadvantage of pypy is that you can't use other libraries out of the box. So if for example you wan to use **pandas** you will need a **pypy** implementation of it. This makes using pypy along common python packages unconvinient. 

  ### 1.3. Numba overview

  **Numba** translates Python functions to optimized machine code at runtime using the industry-standard LLVM compiler library. Numba-compiled numerical algorithms in Python can approach the speeds of C or FORTRAN.

  You don't need to replace the Python interpreter, run a separate compilation step, or even have a C/C++ compiler installed. Just apply one of the Numba decorators to your Python function, and Numba does the rest.

  So you can use python code without modifications and you won't have compatibility problems with other packages when using numba. This is the reason I preffer **numba** over **cython** and **pypy** and it is also one of the faster of the three.

  ## 2. Using numba

  **Numba** provides some decorators that will transform functions to `C`. This way the execution times will be faster.

  By adding the `jit` decorator to a function **numba** will transform it to `C`. For example:

  ```python
  from numba import jit, njit

  @jit
  def m_sum(data):
      out = 0
      for x in data:
          out += x

      return out
  ```

  You can also use `@njit` (equivalent to `@jit(nopython=True)`) which is faster but does not support as much operations as the default ´jit´.


  ## 3. Test numba performance

  ### 3.1. Test `sum` function

  First we will time the execution of different `sum` functions. The first option will be a for loop in python:

  <div class="input">
    iter_and_sum
  </div>
  ```python
  def iter_and_sum(data):
      """ Sums each element in an iterable """
      out = 0
      for x in data:
          out += x

      return out
  ```

  And we will test both `jit` and `njit` **numba** decorators. As an example this is how the `jit` version would be defined:

  <div class="input">
    jit
  </div>
  ```python
  @jit
  def jit_iter_and_sum(data):
      """ Sums each element in an iterable """
      out = 0
      for x in data:
          out += x

      return out

  # Or equivalent:
  jit(iter_and_sum)
  ```

  The other options is to use the `sum()` python function and the `numpy.sum()`.

  For the tests we will try different array lenghts.

  <table class="v-table v-table-right" align="center">
    <tr class="v-table-center">
      <th class="v-table-header">numpy size</th>
      <th class="v-table-header">iter_and_sum</th>
      <th class="v-table-header">jit</th>
      <th class="v-table-header">njit</th>
      <th class="v-table-header">np.sum</th>
      <th class="v-table-header">sum</th>
    </tr>
    <tr>
      <td class="v-table-center">10^4</td>
      <td>0.000926</td>
      <td>0.000001</td>
      <td>0.000001</td>
      <td>0.000008</td>
      <td>0.000750</td>
    </tr>
    <tr>
      <td class="v-table-center">10^5</td>
      <td>0.009162</td>
      <td>0.000009</td>
      <td>0.000010</td>
      <td>0.000042</td>
      <td>0.007408</td>
    </tr>
    <tr>
      <td class="v-table-center">10^6</td>
      <td>0.092395</td>
      <td>0.000106</td>
      <td>0.000120</td>
      <td>0.000408</td>
      <td>0.075894</td>
    </tr>
    <tr>
      <td class="v-table-center">10^7</td>
      <td>0.936200</td>
      <td>0.002313</td>
      <td>0.002345</td>
      <td>0.004393</td>
      <td>0.766890</td>
    </tr>
    <tr>
      <td class="v-table-center">10^8</td>
      <td>9.335412</td>
      <td>0.021232</td>
      <td>0.020506</td>
      <td>0.042701</td>
      <td>7.549756</td>
    </tr>
    <tr>
      <td class="v-table-center">10^9</td>
      <td>96.134125</td>
      <td>0.238718</td>
      <td>0.225308</td>
      <td>0.433185</td>
      <td>76.537118</td>
    </tr>
  </table>

  > First time result has been excluded to avoid computing the time of compilation before calculating the mean.

  It is important to mention that the results would be different using python lists instead of `numpy` arrays.

  <canvas id="chart_sum_times" style="width:100%;height:600px;"></canvas>

  For small arrays `numpy.sum` is the best option but **for large arrays both `jit` and `njit` perform really well**.

  In general is a really good idea to use numpy functions since they use `cython` under the hood.
  In all cases using the raw loop `iter_and_sum` or the default python `sum` gives poor results.

  > **numba** can be **400x** better than a python loop

  ## 4. More info

  You can read the [numba documentation](http://numba.pydata.org/numba-doc/latest/index.html).

  I also suggest you read this post from Jake VanderPlas about [code optimization with numba](https://jakevdp.github.io/blog/2015/02/24/optimizing-python-with-numpy-and-numba/).

scripts: |
  <script>
    var chart_sum_times = new Chart("chart_sum_times", {
      type: 'line',
      data: {
        labels: ['10^4', '10^5', '10^6', '10^7', '10^8', '10^9'],
        datasets: [
          {
            label: 'iter_and_sum',
            borderColor: "#F44336", 
            data: [0.000926, 0.009162, 0.092395, 0.9362, 9.335412, 96.134125],
            fill: false
          },
          {
            label: 'sum',
            borderColor: "#FF9800", 
            data: [0.00075, 0.007408, 0.075894, 0.76689, 7.549756, 76.537118],
            fill: false
          },
          {
            label: 'np.sum',
            borderColor: "#03A9F4", 
            data: [0.000008, 0.000042, 0.000408, 0.004393, 0.042701, 0.433185],
            fill: false
          },
          {
            label: 'jit',
            borderColor: "#8BC34A", 
            data: [0.000001, 0.000009, 0.000106, 0.002313, 0.021232, 0.238718],
            fill: false
          },
          {
            label: 'njit',
            borderColor: "#4CAF50", 
            data: [0.000001, 0.000010, 0.00012, 0.002345, 0.020506, 0.225308],
            fill: false
          },
        ],
      },
      options: {
        title: {
          display: true,
          text: 'Time of different sum functions'
        },
        scales: {
          yAxes: [{
            scaleLabel: {
              display: true,
              labelString: 'Time [s]'
            },
            type: 'logarithmic',
          }],
          xAxes: [{
            scaleLabel: {
              display: true,
              labelString: 'Size of the numpy array'
            },
          }],
        }
      }
    });
  </script>
  